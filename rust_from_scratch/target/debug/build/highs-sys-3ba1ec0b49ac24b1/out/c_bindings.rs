/* automatically generated by rust-bindgen 0.69.4 */

pub const __WORDSIZE: u32 = 64;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const PRId8: &[u8; 4] = b"hhd\0";
pub const PRIi8: &[u8; 4] = b"hhi\0";
pub const PRIo8: &[u8; 4] = b"hho\0";
pub const PRIu8: &[u8; 4] = b"hhu\0";
pub const PRIx8: &[u8; 4] = b"hhx\0";
pub const PRIX8: &[u8; 4] = b"hhX\0";
pub const PRId16: &[u8; 3] = b"hd\0";
pub const PRIi16: &[u8; 3] = b"hi\0";
pub const PRIo16: &[u8; 3] = b"ho\0";
pub const PRIu16: &[u8; 3] = b"hu\0";
pub const PRIx16: &[u8; 3] = b"hx\0";
pub const PRIX16: &[u8; 3] = b"hX\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIdLEAST64: &[u8; 4] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4] = b"llX\0";
pub const PRIdFAST8: &[u8; 4] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4] = b"hho\0";
pub const PRIuFAST8: &[u8; 4] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3] = b"hd\0";
pub const PRIiFAST16: &[u8; 3] = b"hi\0";
pub const PRIoFAST16: &[u8; 3] = b"ho\0";
pub const PRIuFAST16: &[u8; 3] = b"hu\0";
pub const PRIxFAST16: &[u8; 3] = b"hx\0";
pub const PRIXFAST16: &[u8; 3] = b"hX\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIdFAST64: &[u8; 4] = b"lld\0";
pub const PRIiFAST64: &[u8; 4] = b"lli\0";
pub const PRIoFAST64: &[u8; 4] = b"llo\0";
pub const PRIuFAST64: &[u8; 4] = b"llu\0";
pub const PRIxFAST64: &[u8; 4] = b"llx\0";
pub const PRIXFAST64: &[u8; 4] = b"llX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"jd\0";
pub const PRIiMAX: &[u8; 3] = b"ji\0";
pub const PRIoMAX: &[u8; 3] = b"jo\0";
pub const PRIuMAX: &[u8; 3] = b"ju\0";
pub const PRIxMAX: &[u8; 3] = b"jx\0";
pub const PRIXMAX: &[u8; 3] = b"jX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNdLEAST64: &[u8; 4] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4] = b"llx\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3] = b"hd\0";
pub const SCNiFAST16: &[u8; 3] = b"hi\0";
pub const SCNoFAST16: &[u8; 3] = b"ho\0";
pub const SCNuFAST16: &[u8; 3] = b"hu\0";
pub const SCNxFAST16: &[u8; 3] = b"hx\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNdFAST64: &[u8; 4] = b"lld\0";
pub const SCNiFAST64: &[u8; 4] = b"lli\0";
pub const SCNoFAST64: &[u8; 4] = b"llo\0";
pub const SCNuFAST64: &[u8; 4] = b"llu\0";
pub const SCNxFAST64: &[u8; 4] = b"llx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"jd\0";
pub const SCNiMAX: &[u8; 3] = b"ji\0";
pub const SCNoMAX: &[u8; 3] = b"jo\0";
pub const SCNuMAX: &[u8; 3] = b"ju\0";
pub const SCNxMAX: &[u8; 3] = b"jx\0";
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140400;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const CMAKE_BUILD_TYPE: &[u8; 8] = b"Release\0";
pub const CMAKE_INSTALL_PREFIX : & [u8 ; 120] = b"/Users/vivekchaudhary/Documents/progressive_hedging/rust_from_scratch/target/debug/build/highs-sys-3ba1ec0b49ac24b1/out\0" ;
pub const HIGHS_GITHASH: &[u8; 4] = b"n/a\0";
pub const HIGHS_COMPILATION_DATE: &[u8; 11] = b"2024-07-08\0";
pub const HIGHS_VERSION_MAJOR: u32 = 1;
pub const HIGHS_VERSION_MINOR: u32 = 6;
pub const HIGHS_VERSION_PATCH: u32 = 0;
pub const HIGHS_DIR : & [u8 ; 97] = b"/Users/vivekchaudhary/.cargo/registry/src/index.crates.io-6f17d22bba15001f/highs-sys-1.6.2/HiGHS\0" ;
pub const HIGHSINT_FORMAT: &[u8; 2] = b"d\0";
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type wchar_t = __darwin_wchar_t;
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type HighsInt = ::std::os::raw::c_int;
pub type HighsUInt = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HighsCallbackDataOut {
    pub log_type: ::std::os::raw::c_int,
    pub running_time: f64,
    pub simplex_iteration_count: HighsInt,
    pub ipm_iteration_count: HighsInt,
    pub objective_function_value: f64,
    pub mip_node_count: i64,
    pub mip_primal_bound: f64,
    pub mip_dual_bound: f64,
    pub mip_gap: f64,
    pub mip_solution: *mut f64,
}
#[test]
fn bindgen_test_layout_HighsCallbackDataOut() {
    const UNINIT: ::std::mem::MaybeUninit<HighsCallbackDataOut> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HighsCallbackDataOut>(),
        72usize,
        concat!("Size of: ", stringify!(HighsCallbackDataOut))
    );
    assert_eq!(
        ::std::mem::align_of::<HighsCallbackDataOut>(),
        8usize,
        concat!("Alignment of ", stringify!(HighsCallbackDataOut))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HighsCallbackDataOut),
            "::",
            stringify!(log_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).running_time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HighsCallbackDataOut),
            "::",
            stringify!(running_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).simplex_iteration_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HighsCallbackDataOut),
            "::",
            stringify!(simplex_iteration_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipm_iteration_count) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HighsCallbackDataOut),
            "::",
            stringify!(ipm_iteration_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objective_function_value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HighsCallbackDataOut),
            "::",
            stringify!(objective_function_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mip_node_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HighsCallbackDataOut),
            "::",
            stringify!(mip_node_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mip_primal_bound) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HighsCallbackDataOut),
            "::",
            stringify!(mip_primal_bound)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mip_dual_bound) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HighsCallbackDataOut),
            "::",
            stringify!(mip_dual_bound)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mip_gap) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HighsCallbackDataOut),
            "::",
            stringify!(mip_gap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mip_solution) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HighsCallbackDataOut),
            "::",
            stringify!(mip_solution)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HighsCallbackDataIn {
    pub user_interrupt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HighsCallbackDataIn() {
    const UNINIT: ::std::mem::MaybeUninit<HighsCallbackDataIn> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HighsCallbackDataIn>(),
        4usize,
        concat!("Size of: ", stringify!(HighsCallbackDataIn))
    );
    assert_eq!(
        ::std::mem::align_of::<HighsCallbackDataIn>(),
        4usize,
        concat!("Alignment of ", stringify!(HighsCallbackDataIn))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_interrupt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HighsCallbackDataIn),
            "::",
            stringify!(user_interrupt)
        )
    );
}
pub const kHighsMaximumStringLength: HighsInt = 512;
pub const kHighsStatusError: HighsInt = -1;
pub const kHighsStatusOk: HighsInt = 0;
pub const kHighsStatusWarning: HighsInt = 1;
pub const kHighsVarTypeContinuous: HighsInt = 0;
pub const kHighsVarTypeInteger: HighsInt = 1;
pub const kHighsVarTypeSemiContinuous: HighsInt = 2;
pub const kHighsVarTypeSemiInteger: HighsInt = 3;
pub const kHighsVarTypeImplicitInteger: HighsInt = 4;
pub const kHighsOptionTypeBool: HighsInt = 0;
pub const kHighsOptionTypeInt: HighsInt = 1;
pub const kHighsOptionTypeDouble: HighsInt = 2;
pub const kHighsOptionTypeString: HighsInt = 3;
pub const kHighsInfoTypeInt64: HighsInt = -1;
pub const kHighsInfoTypeInt: HighsInt = 1;
pub const kHighsInfoTypeDouble: HighsInt = 2;
pub const kHighsObjSenseMinimize: HighsInt = 1;
pub const kHighsObjSenseMaximize: HighsInt = -1;
pub const kHighsMatrixFormatColwise: HighsInt = 1;
pub const kHighsMatrixFormatRowwise: HighsInt = 2;
pub const kHighsHessianFormatTriangular: HighsInt = 1;
pub const kHighsHessianFormatSquare: HighsInt = 2;
pub const kHighsSolutionStatusNone: HighsInt = 0;
pub const kHighsSolutionStatusInfeasible: HighsInt = 1;
pub const kHighsSolutionStatusFeasible: HighsInt = 2;
pub const kHighsBasisValidityInvalid: HighsInt = 0;
pub const kHighsBasisValidityValid: HighsInt = 1;
pub const kHighsPresolveStatusNotPresolved: HighsInt = -1;
pub const kHighsPresolveStatusNotReduced: HighsInt = 0;
pub const kHighsPresolveStatusInfeasible: HighsInt = 1;
pub const kHighsPresolveStatusUnboundedOrInfeasible: HighsInt = 2;
pub const kHighsPresolveStatusReduced: HighsInt = 3;
pub const kHighsPresolveStatusReducedToEmpty: HighsInt = 4;
pub const kHighsPresolveStatusTimeout: HighsInt = 5;
pub const kHighsPresolveStatusNullError: HighsInt = 6;
pub const kHighsPresolveStatusOptionsError: HighsInt = 7;
pub const kHighsModelStatusNotset: HighsInt = 0;
pub const kHighsModelStatusLoadError: HighsInt = 1;
pub const kHighsModelStatusModelError: HighsInt = 2;
pub const kHighsModelStatusPresolveError: HighsInt = 3;
pub const kHighsModelStatusSolveError: HighsInt = 4;
pub const kHighsModelStatusPostsolveError: HighsInt = 5;
pub const kHighsModelStatusModelEmpty: HighsInt = 6;
pub const kHighsModelStatusOptimal: HighsInt = 7;
pub const kHighsModelStatusInfeasible: HighsInt = 8;
pub const kHighsModelStatusUnboundedOrInfeasible: HighsInt = 9;
pub const kHighsModelStatusUnbounded: HighsInt = 10;
pub const kHighsModelStatusObjectiveBound: HighsInt = 11;
pub const kHighsModelStatusObjectiveTarget: HighsInt = 12;
pub const kHighsModelStatusTimeLimit: HighsInt = 13;
pub const kHighsModelStatusIterationLimit: HighsInt = 14;
pub const kHighsModelStatusUnknown: HighsInt = 15;
pub const kHighsModelStatusSolutionLimit: HighsInt = 16;
pub const kHighsModelStatusInterrupt: HighsInt = 17;
pub const kHighsBasisStatusLower: HighsInt = 0;
pub const kHighsBasisStatusBasic: HighsInt = 1;
pub const kHighsBasisStatusUpper: HighsInt = 2;
pub const kHighsBasisStatusZero: HighsInt = 3;
pub const kHighsBasisStatusNonbasic: HighsInt = 4;
pub const kHighsCallbackLogging: HighsInt = 0;
pub const kHighsCallbackSimplexInterrupt: HighsInt = 1;
pub const kHighsCallbackIpmInterrupt: HighsInt = 2;
pub const kHighsCallbackMipImprovingSolution: HighsInt = 3;
pub const kHighsCallbackMipLogging: HighsInt = 4;
pub const kHighsCallbackMipInterrupt: HighsInt = 5;
extern "C" {
    #[doc = " Formulate and solve a linear program using HiGHS.\n\n @param num_col   The number of columns.\n @param num_row   The number of rows.\n @param num_nz    The number of nonzeros in the constraint matrix.\n @param a_format  The format of the constraint matrix as a\n                  `kHighsMatrixFormat` constant.\n @param sense     The optimization sense as a `kHighsObjSense` constant.\n @param offset    The objective constant.\n @param col_cost  An array of length [num_col] with the column costs.\n @param col_lower An array of length [num_col] with the column lower bounds.\n @param col_upper An array of length [num_col] with the column upper bounds.\n @param row_lower An array of length [num_row] with the row lower bounds.\n @param row_upper An array of length [num_row] with the row upper bounds.\n @param a_start   The constraint matrix is provided to HiGHS in compressed\n                  sparse column form (if `a_format` is\n                  `kHighsMatrixFormatColwise`, otherwise compressed sparse row\n                  form). The sparse matrix consists of three arrays,\n                  `a_start`, `a_index`, and `a_value`. `a_start` is an array\n                  of length [num_col] containing the starting index of each\n                  column in `a_index`. If `a_format` is\n                  `kHighsMatrixFormatRowwise` the array is of length [num_row]\n                  corresponding to each row.\n @param a_index   An array of length [num_nz] with indices of matrix entries.\n @param a_value   An array of length [num_nz] with values of matrix entries.\n\n @param col_value      An array of length [num_col], to be filled with the\n                       primal column solution.\n @param col_dual       An array of length [num_col], to be filled with the\n                       dual column solution.\n @param row_value      An array of length [num_row], to be filled with the\n                       primal row solution.\n @param row_dual       An array of length [num_row], to be filled with the\n                       dual row solution.\n @param col_basis_status  An array of length [num_col], to be filled with the\n                          basis status of the columns in the form of a\n                          `kHighsBasisStatus` constant.\n @param row_basis_status  An array of length [num_row], to be filled with the\n                          basis status of the rows in the form of a\n                          `kHighsBasisStatus` constant.\n @param model_status      The location in which to place the termination\n                          status of the model after the solve in the form of a\n                          `kHighsModelStatus` constant.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_lpCall(
        num_col: HighsInt,
        num_row: HighsInt,
        num_nz: HighsInt,
        a_format: HighsInt,
        sense: HighsInt,
        offset: f64,
        col_cost: *const f64,
        col_lower: *const f64,
        col_upper: *const f64,
        row_lower: *const f64,
        row_upper: *const f64,
        a_start: *const HighsInt,
        a_index: *const HighsInt,
        a_value: *const f64,
        col_value: *mut f64,
        col_dual: *mut f64,
        row_value: *mut f64,
        row_dual: *mut f64,
        col_basis_status: *mut HighsInt,
        row_basis_status: *mut HighsInt,
        model_status: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Formulate and solve a mixed-integer linear program using HiGHS.\n\n The signature of this method is identical to `Highs_lpCall`, except that it\n has an additional `integrality` argument, and that it is missing the\n `col_dual`, `row_dual`, `col_basis_status` and `row_basis_status` arguments.\n\n @param integrality   An array of length [num_col], containing a\n                      `kHighsVarType` constant for each column.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_mipCall(
        num_col: HighsInt,
        num_row: HighsInt,
        num_nz: HighsInt,
        a_format: HighsInt,
        sense: HighsInt,
        offset: f64,
        col_cost: *const f64,
        col_lower: *const f64,
        col_upper: *const f64,
        row_lower: *const f64,
        row_upper: *const f64,
        a_start: *const HighsInt,
        a_index: *const HighsInt,
        a_value: *const f64,
        integrality: *const HighsInt,
        col_value: *mut f64,
        row_value: *mut f64,
        model_status: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Formulate and solve a quadratic program using HiGHS.\n\n The signature of this method is identical to `Highs_lpCall`, except that it\n has additional arguments for specifying the Hessian matrix.\n\n @param q_num_nz  The number of nonzeros in the Hessian matrix.\n @param q_format  The format of the Hessian matrix in the form of a\n                  `kHighsHessianStatus` constant. If q_num_nz > 0, this must\n                  be `kHighsHessianFormatTriangular`.\n @param q_start   The Hessian matrix is provided in the same format as the\n                  constraint matrix, using `q_start`, `q_index`, and `q_value`\n                  in the place of `a_start`, `a_index`, and `a_value`.\n @param q_index   An array of length [q_num_nz] with indices of matrix\n                  sentries.\n @param q_value   An array of length [q_num_nz] with values of matrix entries.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_qpCall(
        num_col: HighsInt,
        num_row: HighsInt,
        num_nz: HighsInt,
        q_num_nz: HighsInt,
        a_format: HighsInt,
        q_format: HighsInt,
        sense: HighsInt,
        offset: f64,
        col_cost: *const f64,
        col_lower: *const f64,
        col_upper: *const f64,
        row_lower: *const f64,
        row_upper: *const f64,
        a_start: *const HighsInt,
        a_index: *const HighsInt,
        a_value: *const f64,
        q_start: *const HighsInt,
        q_index: *const HighsInt,
        q_value: *const f64,
        col_value: *mut f64,
        col_dual: *mut f64,
        row_value: *mut f64,
        row_dual: *mut f64,
        col_basis_status: *mut HighsInt,
        row_basis_status: *mut HighsInt,
        model_status: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Create a Highs instance and return the reference.\n\n Call `Highs_destroy` on the returned reference to clean up allocated memory.\n\n @returns A pointer to the Highs instance."]
    pub fn Highs_create() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Destroy the model `highs` created by `Highs_create` and free all\n corresponding memory. Future calls using `highs` are not allowed.\n\n To empty a model without invalidating `highs`, see `Highs_clearModel`.\n\n @param highs     A pointer to the Highs instance."]
    pub fn Highs_destroy(highs: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Return the HiGHS version number as a string of the form \"vX.Y.Z\".\n\n @returns The HiGHS version as a `char*`."]
    pub fn Highs_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the HiGHS major version number.\n\n @returns The HiGHS major version number."]
    pub fn Highs_versionMajor() -> HighsInt;
}
extern "C" {
    #[doc = " Return the HiGHS minor version number.\n\n @returns The HiGHS minor version number."]
    pub fn Highs_versionMinor() -> HighsInt;
}
extern "C" {
    #[doc = " Return the HiGHS patch version number.\n\n @returns The HiGHS patch version number."]
    pub fn Highs_versionPatch() -> HighsInt;
}
extern "C" {
    #[doc = " Return the HiGHS githash.\n\n @returns The HiGHS githash."]
    pub fn Highs_githash() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the HiGHS compilation date.\n\n @returns Thse HiGHS compilation date."]
    pub fn Highs_compilationDate() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Read a model from `filename` into `highs`.\n\n @param highs     A pointer to the Highs instance.\n @param filename  The filename to read.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_readModel(
        highs: *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Write the model in `highs` to `filename`.\n\n @param highs     A pointer to the Highs instance.\n @param filename  The filename to write.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_writeModel(
        highs: *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Reset the options and then call `clearModel`.\n\n See `Highs_destroy` to free all associated memory.\n\n @param highs     A pointer to the Highs instance.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_clear(highs: *mut ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    #[doc = " Remove all variables and constraints from the model `highs`, but do not\n invalidate the pointer `highs`. Future calls (for example, adding new\n variables and constraints) are allowed.\n\n @param highs     A pointer to the Highs instance.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_clearModel(highs: *mut ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    #[doc = " Clear all solution data associated with the model.\n\n See `Highs_destroy` to clear the model and free all associated memory.\n\n @param highs     A pointer to the Highs instance.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_clearSolver(highs: *mut ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    #[doc = " Optimize a model. The algorithm used by HiGHS depends on the options that\n have been set.\n\n @param highs     A pointer to the Highs instance.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_run(highs: *mut ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    #[doc = " Write the solution information (including dual and basis status, if\n available) to a file.\n\n See also: `Highs_writeSolutionPretty`.\n\n @param highs     A pointer to the Highs instance.\n @param filename  The name of the file to write the results to.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_writeSolution(
        highs: *const ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Write the solution information (including dual and basis status, if\n available) to a file in a human-readable format.\n\n The method identical to `Highs_writeSolution`, except that the\n printout is in a human-readiable format.\n\n @param highs     A pointer to the Highs instance.\n @param filename  The name of the file to write the results to.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_writeSolutionPretty(
        highs: *const ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Pass a linear program (LP) to HiGHS in a single function call.\n\n The signature of this function is identical to `Highs_passModel`, without the\n arguments for passing the Hessian matrix of a quadratic program and the\n integrality vector.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_passLp(
        highs: *mut ::std::os::raw::c_void,
        num_col: HighsInt,
        num_row: HighsInt,
        num_nz: HighsInt,
        a_format: HighsInt,
        sense: HighsInt,
        offset: f64,
        col_cost: *const f64,
        col_lower: *const f64,
        col_upper: *const f64,
        row_lower: *const f64,
        row_upper: *const f64,
        a_start: *const HighsInt,
        a_index: *const HighsInt,
        a_value: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Pass a mixed-integer linear program (MILP) to HiGHS in a single function\n call.\n\n The signature of function is identical to `Highs_passModel`, without the\n arguments for passing the Hessian matrix of a quadratic program.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_passMip(
        highs: *mut ::std::os::raw::c_void,
        num_col: HighsInt,
        num_row: HighsInt,
        num_nz: HighsInt,
        a_format: HighsInt,
        sense: HighsInt,
        offset: f64,
        col_cost: *const f64,
        col_lower: *const f64,
        col_upper: *const f64,
        row_lower: *const f64,
        row_upper: *const f64,
        a_start: *const HighsInt,
        a_index: *const HighsInt,
        a_value: *const f64,
        integrality: *const HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Pass a model to HiGHS in a single function call. This is faster than\n constructing the model using `Highs_addRow` and `Highs_addCol`.\n\n @param highs       A pointer to the Highs instance.\n @param num_col     The number of columns.\n @param num_row     The number of rows.\n @param num_nz      The number of elements in the constraint matrix.\n @param q_num_nz    The number of elements in the Hessian matrix.\n @param a_format    The format of the constraint matrix to use in the form of\n                    a `kHighsMatrixFormat` constant.\n @param q_format    The format of the Hessian matrix to use in the form of a\n                    `kHighsHessianFormat` constant.\n @param sense       The optimization sense in the form of a `kHighsObjSense`\n                    constant.\n @param offset      The constant term in the objective function.\n @param col_cost    An array of length [num_col] with the objective\n                    coefficients.\n @param col_lower   An array of length [num_col] with the lower column bounds.\n @param col_upper   An array of length [num_col] with the upper column bounds.\n @param row_lower   An array of length [num_row] with the upper row bounds.\n @param row_upper   An array of length [num_row] with the upper row bounds.\n @param a_start     The constraint matrix is provided to HiGHS in compressed\n                    sparse column form (if `a_format` is\n                    `kHighsMatrixFormatColwise`, otherwise compressed sparse\n                    row form). The sparse matrix consists of three arrays,\n                    `a_start`, `a_index`, and `a_value`. `a_start` is an array\n                    of length [num_col] containing the starting index of each\n                    column in `a_index`. If `a_format` is\n                    `kHighsMatrixFormatRowwise` the array is of length\n                    [num_row] corresponding to each row.\n @param a_index     An array of length [num_nz] with indices of matrix\n                    entries.\n @param a_value     An array of length [num_nz] with values of matrix entries.\n @param q_start     The Hessian matrix is provided in the same format as the\n                    constraint matrix, using `q_start`, `q_index`, and\n                    `q_value` in the place of `a_start`, `a_index`, and\n                    `a_value`. If the model is linear, pass NULL.\n @param q_index     An array of length [q_num_nz] with indices of matrix\n                    entries. If the model is linear, pass NULL.\n @param q_value     An array of length [q_num_nz] with values of matrix\n                     entries. If the model is linear, pass NULL.\n @param integrality An array of length [num_col] containing a `kHighsVarType`\n                    consatnt for each column.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_passModel(
        highs: *mut ::std::os::raw::c_void,
        num_col: HighsInt,
        num_row: HighsInt,
        num_nz: HighsInt,
        q_num_nz: HighsInt,
        a_format: HighsInt,
        q_format: HighsInt,
        sense: HighsInt,
        offset: f64,
        col_cost: *const f64,
        col_lower: *const f64,
        col_upper: *const f64,
        row_lower: *const f64,
        row_upper: *const f64,
        a_start: *const HighsInt,
        a_index: *const HighsInt,
        a_value: *const f64,
        q_start: *const HighsInt,
        q_index: *const HighsInt,
        q_value: *const f64,
        integrality: *const HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Set the Hessian matrix for a quadratic objective.\n\n @param highs     A pointer to the Highs instance.\n @param dim       The dimension of the Hessian matrix. Should be [num_col].\n @param num_nz    The number of non-zero elements in the Hessian matrix.\n @param format    The format of the Hessian matrix as a `kHighsHessianFormat`\n                  constant. This must be `kHighsHessianFormatTriangular`.\n @param start     The Hessian matrix is provided to HiGHS as the upper\n                  triangular component in compressed sparse column form. The\n                  sparse matrix consists of three arrays, `start`, `index`,\n                  and `value`. `start` is an array of length [num_col]\n                  containing the starting index of each column in `index`.\n @param index     An array of length [num_nz] with indices of matrix entries.\n @param value     An array of length [num_nz] with values of matrix entries.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_passHessian(
        highs: *mut ::std::os::raw::c_void,
        dim: HighsInt,
        num_nz: HighsInt,
        format: HighsInt,
        start: *const HighsInt,
        index: *const HighsInt,
        value: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Pass the name of a row.\n\n @param highs A pointer to the Highs instance.\n @param row   The row for which the name is supplied.\n @param name  The name of the row.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_passRowName(
        highs: *const ::std::os::raw::c_void,
        row: HighsInt,
        name: *const ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Pass the name of a column.\n\n @param highs A pointer to the Highs instance.\n @param col   The column for which the name is supplied.\n @param name  The name of the column.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_passColName(
        highs: *const ::std::os::raw::c_void,
        col: HighsInt,
        name: *const ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Read the option values from file.\n\n @param highs     A pointer to the Highs instance.\n @param filename  The filename from which to read the option values.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_readOptions(
        highs: *const ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Set a boolean-valued option.\n\n @param highs     A pointer to the Highs instance.\n @param option    The name of the option.\n @param value     The new value of the option.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_setBoolOptionValue(
        highs: *mut ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Set an int-valued option.\n\n @param highs     A pointer to the Highs instance.\n @param option    The name of the option.\n @param value     The new value of the option.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_setIntOptionValue(
        highs: *mut ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Set a double-valued option.\n\n @param highs     A pointer to the Highs instance.\n @param option    The name of the option.\n @param value     The new value of the option.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_setDoubleOptionValue(
        highs: *mut ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Set a string-valued option.\n\n @param highs     A pointer to the Highs instance.\n @param option    The name of the option.\n @param value     The new value of the option.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_setStringOptionValue(
        highs: *mut ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get a boolean-valued option.\n\n @param highs     A pointer to the Highs instance.\n @param option    The name of the option.\n @param value     The location in which the current value of the option should\n                  be placed.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getBoolOptionValue(
        highs: *const ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get an int-valued option.\n\n @param highs     A pointer to the Highs instance.\n @param option    The name of the option.\n @param value     The location in which the current value of the option should\n                  be placed.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getIntOptionValue(
        highs: *const ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get a double-valued option.\n\n @param highs     A pointer to the Highs instance.\n @param option    The name of the option.\n @param value     The location in which the current value of the option should\n                  be placed.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getDoubleOptionValue(
        highs: *const ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: *mut f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get a string-valued option.\n\n @param highs     A pointer to the Highs instance.\n @param option    The name of the option.\n @param value     A pointer to allocated memory (of at least\n                  `kMaximumStringLength`) to store the current value of the\n                  option.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getStringOptionValue(
        highs: *const ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get the type expected by an option.\n\n @param highs     A pointer to the Highs instance.\n @param option    The name of the option.\n @param type      An int in which the corresponding `kHighsOptionType`\n                  constant should be placed.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getOptionType(
        highs: *const ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        type_: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Reset all options to their default value.\n\n @param highs     A pointer to the Highs instance.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_resetOptions(highs: *mut ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    #[doc = " Write the current options to file.\n\n @param highs     A pointer to the Highs instance.\n @param filename  The filename to write the options to.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_writeOptions(
        highs: *const ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Write the value of non-default options to file.\n\n This is similar to `Highs_writeOptions`, except only options with\n non-default value are written to `filename`.\n\n @param highs     A pointer to the Highs instance.\n @param filename  The filename to write the options to.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_writeOptionsDeviations(
        highs: *const ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Return the number of options\n\n @param highs     A pointer to the Highs instance."]
    pub fn Highs_getNumOptions(highs: *const ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    #[doc = " Get the name of an option identified by index\n\n @param highs     A pointer to the Highs instance.\n @param index     The index of the option.\n @param name      The name of the option.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getOptionName(
        highs: *const ::std::os::raw::c_void,
        index: HighsInt,
        name: *mut *mut ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get the current and default values of a bool option\n\n @param highs         A pointer to the Highs instance.\n @param current_value A pointer to the current value of the option.\n @param default_value A pointer to the default value of the option.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getBoolOptionValues(
        highs: *const ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        current_value: *mut HighsInt,
        default_value: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get the current and default values of an int option\n\n @param highs         A pointer to the Highs instance.\n @param current_value A pointer to the current value of the option.\n @param min_value     A pointer to the minimum value of the option.\n @param max_value     A pointer to the maximum value of the option.\n @param default_value A pointer to the default value of the option.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getIntOptionValues(
        highs: *const ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        current_value: *mut HighsInt,
        min_value: *mut HighsInt,
        max_value: *mut HighsInt,
        default_value: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get the current and default values of a double option\n\n @param highs         A pointer to the Highs instance.\n @param current_value A pointer to the current value of the option.\n @param min_value     A pointer to the minimum value of the option.\n @param max_value     A pointer to the maximum value of the option.\n @param default_value A pointer to the default value of the option.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getDoubleOptionValues(
        highs: *const ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        current_value: *mut f64,
        min_value: *mut f64,
        max_value: *mut f64,
        default_value: *mut f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get the current and default values of a string option\n\n @param highs         A pointer to the Highs instance.\n @param current_value A pointer to the current value of the option.\n @param default_value A pointer to the default value of the option.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getStringOptionValues(
        highs: *const ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        current_value: *mut ::std::os::raw::c_char,
        default_value: *mut ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get an int-valued info value.\n\n @param highs     A pointer to the Highs instance.\n @param info      The name of the info item.\n @param value     A reference to an integer that the result will be stored in.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getIntInfoValue(
        highs: *const ::std::os::raw::c_void,
        info: *const ::std::os::raw::c_char,
        value: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get a double-valued info value.\n\n @param highs     A pointer to the Highs instance.\n @param info      The name of the info item.\n @param value     A reference to a double that the result will be stored in.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getDoubleInfoValue(
        highs: *const ::std::os::raw::c_void,
        info: *const ::std::os::raw::c_char,
        value: *mut f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get an int64-valued info value.\n\n @param highs     A pointer to the Highs instance.\n @param info      The name of the info item.\n @param value     A reference to an int64 that the result will be stored in.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getInt64InfoValue(
        highs: *const ::std::os::raw::c_void,
        info: *const ::std::os::raw::c_char,
        value: *mut i64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get the type expected by an info item.\n\n @param highs     A pointer to the Highs instance.\n @param info      The name of the info item.\n @param type      An int in which the corresponding `kHighsOptionType`\n                  constant is stored.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getInfoType(
        highs: *const ::std::os::raw::c_void,
        info: *const ::std::os::raw::c_char,
        type_: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get the primal and dual solution from an optimized model.\n\n @param highs      A pointer to the Highs instance.\n @param col_value  An array of length [num_col], to be filled with primal\n                   column values.\n @param col_dual   An array of length [num_col], to be filled with dual column\n                   values.\n @param row_value  An array of length [num_row], to be filled with primal row\n                   values.\n @param row_dual   An array of length [num_row], to be filled with dual row\n                   values.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getSolution(
        highs: *const ::std::os::raw::c_void,
        col_value: *mut f64,
        col_dual: *mut f64,
        row_value: *mut f64,
        row_dual: *mut f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Given a linear program with a basic feasible solution, get the column and row\n basis statuses.\n\n @param highs       A pointer to the Highs instance.\n @param col_status  An array of length [num_col], to be filled with the column\n                    basis statuses in the form of a `kHighsBasisStatus`\n                    constant.\n @param row_status  An array of length [num_row], to be filled with the row\n                    basis statuses in the form of a `kHighsBasisStatus`\n                    constant.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getBasis(
        highs: *const ::std::os::raw::c_void,
        col_status: *mut HighsInt,
        row_status: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Return the optimization status of the model in the form of a\n `kHighsModelStatus` constant.\n\n @param highs     A pointer to the Highs instance.\n\n @returns An integer corresponding to the `kHighsModelStatus` constant"]
    pub fn Highs_getModelStatus(highs: *const ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    #[doc = " Get an unbounded dual ray that is a certificate of primal infeasibility.\n\n @param highs             A pointer to the Highs instance.\n @param has_dual_ray      A pointer to an int to store 1 if the dual ray\n                          exists.\n @param dual_ray_value    An array of length [num_row] filled with the\n                          unbounded ray.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getDualRay(
        highs: *const ::std::os::raw::c_void,
        has_dual_ray: *mut HighsInt,
        dual_ray_value: *mut f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get an unbounded primal ray that is a certificate of dual infeasibility.\n\n @param highs             A pointer to the Highs instance.\n @param has_primal_ray    A pointer to an int to store 1 if the primal ray\n                          exists.\n @param primal_ray_value  An array of length [num_col] filled with the\n                          unbounded ray.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getPrimalRay(
        highs: *const ::std::os::raw::c_void,
        has_primal_ray: *mut HighsInt,
        primal_ray_value: *mut f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get the primal objective function value.\n\n @param highs     A pointer to the Highs instance.\n\n @returns The primal objective function value"]
    pub fn Highs_getObjectiveValue(highs: *const ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[doc = " Get the indices of the rows and columns that make up the basis matrix ``B``\n of a basic feasible solution.\n\n Non-negative entries are indices of columns, and negative entries are\n `-row_index - 1`. For example, `{1, -1}` would be the second column and first\n row.\n\n The order of these rows and columns is important for calls to the functions:\n\n  - `Highs_getBasisInverseRow`\n  - `Highs_getBasisInverseCol`\n  - `Highs_getBasisSolve`\n  - `Highs_getBasisTransposeSolve`\n  - `Highs_getReducedRow`\n  - `Highs_getReducedColumn`\n\n @param highs             A pointer to the Highs instance.\n @param basic_variables   An array of size [num_rows], filled with the indices\n                          of the basic variables.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getBasicVariables(
        highs: *const ::std::os::raw::c_void,
        basic_variables: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get a row of the inverse basis matrix ``B^{-1}``.\n\n See `Highs_getBasicVariables` for a description of the ``B`` matrix.\n\n The arrays `row_vector` and `row_index` must have an allocated length of\n [num_row]. However, check `row_num_nz` to see how many non-zero elements are\n actually stored.\n\n @param highs         A pointer to the Highs instance.\n @param row           The index of the row to compute.\n @param row_vector    An array of length [num_row] in which to store the\n                      values of the non-zero elements.\n @param row_num_nz    The number of non-zeros in the row.\n @param row_index     An array of length [num_row] in which to store the\n                      indices of the non-zero elements.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getBasisInverseRow(
        highs: *const ::std::os::raw::c_void,
        row: HighsInt,
        row_vector: *mut f64,
        row_num_nz: *mut HighsInt,
        row_index: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get a column of the inverse basis matrix ``B^{-1}``.\n\n See `Highs_getBasicVariables` for a description of the ``B`` matrix.\n\n The arrays `col_vector` and `col_index` must have an allocated length of\n [num_row]. However, check `col_num_nz` to see how many non-zero elements are\n actually stored.\n\n @param highs         A pointer to the Highs instance.\n @param col           The index of the column to compute.\n @param col_vector    An array of length [num_row] in which to store the\n                      values of the non-zero elements.\n @param col_num_nz    The number of non-zeros in the column.\n @param col_index     An array of length [num_row] in which to store the\n                      indices of the non-zero elements.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getBasisInverseCol(
        highs: *const ::std::os::raw::c_void,
        col: HighsInt,
        col_vector: *mut f64,
        col_num_nz: *mut HighsInt,
        col_index: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Compute ``\\mathbf{x}=B^{-1}\\mathbf{b}`` for a given vector\n ``\\mathbf{b}``.\n\n See `Highs_getBasicVariables` for a description of the ``B`` matrix.\n\n The arrays `solution_vector` and `solution_index` must have an allocated\n length of [num_row]. However, check `solution_num_nz` to see how many\n non-zero elements are actually stored.\n\n @param highs             A pointer to the Highs instance.\n @param rhs               The right-hand side vector ``b``.\n @param solution_vector   An array of length [num_row] in which to store the\n                          values of the non-zero elements.\n @param solution_num_nz   The number of non-zeros in the solution.\n @param solution_index    An array of length [num_row] in which to store the\n                          indices of the non-zero elements.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getBasisSolve(
        highs: *const ::std::os::raw::c_void,
        rhs: *const f64,
        solution_vector: *mut f64,
        solution_num_nz: *mut HighsInt,
        solution_index: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Compute ``\\mathbf{x}=B^{-T}\\mathbf{b}`` for a given vector\n ``\\mathbf{b}``.\n\n See `Highs_getBasicVariables` for a description of the ``B`` matrix.\n\n The arrays `solution_vector` and `solution_index` must have an allocated\n length of [num_row]. However, check `solution_num_nz` to see how many\n non-zero elements are actually stored.\n\n @param highs             A pointer to the Highs instance.\n @param rhs               The right-hand side vector ``b``\n @param solution_vector   An array of length [num_row] in whcih to store the\n                          values of the non-zero elements.\n @param solution_num_nz   The number of non-zeros in the solution.\n @param solution_index    An array of length [num_row] in whcih to store the\n                          indices of the non-zero elements.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getBasisTransposeSolve(
        highs: *const ::std::os::raw::c_void,
        rhs: *const f64,
        solution_vector: *mut f64,
        solution_nz: *mut HighsInt,
        solution_index: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Compute a row of ``B^{-1}A``.\n\n See `Highs_getBasicVariables` for a description of the ``B`` matrix.\n\n The arrays `row_vector` and `row_index` must have an allocated length of\n [num_row]. However, check `row_num_nz` to see how many non-zero elements are\n actually stored.\n\n @param highs         A pointer to the Highs instance.\n @param row           The index of the row to compute.\n @param row_vector    An array of length [num_row] in which to store the\n                      values of the non-zero elements.\n @param row_num_nz    The number of non-zeros in the row.\n @param row_index     An array of length [num_row] in which to store the\n                      indices of the non-zero elements.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getReducedRow(
        highs: *const ::std::os::raw::c_void,
        row: HighsInt,
        row_vector: *mut f64,
        row_num_nz: *mut HighsInt,
        row_index: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Compute a column of ``B^{-1}A``.\n\n See `Highs_getBasicVariables` for a description of the ``B`` matrix.\n\n The arrays `col_vector` and `col_index` must have an allocated length of\n [num_row]. However, check `col_num_nz` to see how many non-zero elements are\n actually stored.\n\n @param highs         A pointer to the Highs instance.\n @param col           The index of the column to compute.\n @param col_vector    An array of length [num_row] in which to store the\n                       values of the non-zero elements.\n @param col_num_nz    The number of non-zeros in the column.\n @param col_index     An array of length [num_row] in which to store the\n                       indices of the non-zero elements.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getReducedColumn(
        highs: *const ::std::os::raw::c_void,
        col: HighsInt,
        col_vector: *mut f64,
        col_num_nz: *mut HighsInt,
        col_index: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Set a basic feasible solution by passing the column and row basis statuses to\n the model.\n\n @param highs       A pointer to the Highs instance.\n @param col_status  an array of length [num_col] with the column basis status\n                    in the form of `kHighsBasisStatus` constants\n @param row_status  an array of length [num_row] with the row basis status\n                    in the form of `kHighsBasisStatus` constants\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_setBasis(
        highs: *mut ::std::os::raw::c_void,
        col_status: *const HighsInt,
        row_status: *const HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Set a logical basis in the model.\n\n @param highs     A pointer to the Highs instance.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_setLogicalBasis(highs: *mut ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    #[doc = " Set a solution by passing the column and row primal and dual solution values.\n\n For any values that are unavailable, pass NULL.\n\n @param highs       A pointer to the Highs instance.\n @param col_value   An array of length [num_col] with the column solution\n                    values.\n @param row_value   An array of length [num_row] with the row solution\n                    values.\n @param col_dual    An array of length [num_col] with the column dual values.\n @param row_dual    An array of length [num_row] with the row dual values.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_setSolution(
        highs: *mut ::std::os::raw::c_void,
        col_value: *const f64,
        row_value: *const f64,
        col_dual: *const f64,
        row_dual: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Set the callback method to use for HiGHS\n\n @param highs              A pointer to the Highs instance.\n @param user_callback      A pointer to the user callback\n @param user_callback_data A pointer to the user callback data\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_setCallback(
        highs: *mut ::std::os::raw::c_void,
        user_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: *const ::std::os::raw::c_char,
                arg3: *const HighsCallbackDataOut,
                arg4: *mut HighsCallbackDataIn,
                arg5: *mut ::std::os::raw::c_void,
            ),
        >,
        user_callback_data: *mut ::std::os::raw::c_void,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Start callback of given type\n\n @param highs         A pointer to the Highs instance.\n @param callback_type The type of callback to be started\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_startCallback(
        highs: *mut ::std::os::raw::c_void,
        callback_type: ::std::os::raw::c_int,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Stop callback of given type\n\n @param highs         A pointer to the Highs instance.\n @param callback_type The type of callback to be stopped\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_stopCallback(
        highs: *mut ::std::os::raw::c_void,
        callback_type: ::std::os::raw::c_int,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Return the cumulative wall-clock time spent in `Highs_run`.\n\n @param highs     A pointer to the Highs instance.\n\n @returns The cumulative wall-clock time spent in `Highs_run`"]
    pub fn Highs_getRunTime(highs: *const ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[doc = " Reset the clocks in a `highs` model.\n\n Each `highs` model contains a single instance of clock that records how much\n time is spent in various parts of the algorithm. This clock is not reset on\n entry to `Highs_run`, so repeated calls to `Highs_run` report the cumulative\n time spent in the algorithm. A side-effect is that this will trigger a time\n limit termination once the cumulative run time exceeds the time limit, rather\n than the run time of each individual call to `Highs_run`.\n\n As a work-around, call `Highs_zeroAllClocks` before each call to `Highs_run`.\n\n @param highs     A pointer to the Highs instance.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_zeroAllClocks(highs: *const ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    #[doc = " Add a new column (variable) to the model.\n\n @param highs         A pointer to the Highs instance.\n @param cost          The objective coefficient of the column.\n @param lower         The lower bound of the column.\n @param upper         The upper bound of the column.\n @param num_new_nz    The number of non-zeros in the column.\n @param index         An array of size [num_new_nz] with the row indices.\n @param value         An array of size [num_new_nz] with row values.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_addCol(
        highs: *mut ::std::os::raw::c_void,
        cost: f64,
        lower: f64,
        upper: f64,
        num_new_nz: HighsInt,
        index: *const HighsInt,
        value: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Add multiple columns (variables) to the model.\n\n @param highs         A pointer to the Highs instance.\n @param num_new_col   The number of new columns to add.\n @param costs         An array of size [num_new_col] with objective\n                      coefficients.\n @param lower         An array of size [num_new_col] with lower bounds.\n @param upper         An array of size [num_new_col] with upper bounds.\n @param num_new_nz    The number of new nonzeros in the constraint matrix.\n @param starts        The constraint coefficients are given as a matrix in\n                      compressed sparse column form by the arrays `starts`,\n                      `index`, and `value`. `starts` is an array of size\n                      [num_new_cols] with the start index of each row in\n                      indices and values.\n @param index         An array of size [num_new_nz] with row indices.\n @param value         An array of size [num_new_nz] with row values.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_addCols(
        highs: *mut ::std::os::raw::c_void,
        num_new_col: HighsInt,
        costs: *const f64,
        lower: *const f64,
        upper: *const f64,
        num_new_nz: HighsInt,
        starts: *const HighsInt,
        index: *const HighsInt,
        value: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Add a new variable to the model.\n\n @param highs         A pointer to the Highs instance.\n @param lower         The lower bound of the column.\n @param upper         The upper bound of the column.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_addVar(highs: *mut ::std::os::raw::c_void, lower: f64, upper: f64) -> HighsInt;
}
extern "C" {
    #[doc = " Add multiple variables to the model.\n\n @param highs         A pointer to the Highs instance.\n @param num_new_var   The number of new variables to add.\n @param lower         An array of size [num_new_var] with lower bounds.\n @param upper         An array of size [num_new_var] with upper bounds.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_addVars(
        highs: *mut ::std::os::raw::c_void,
        num_new_var: HighsInt,
        lower: *const f64,
        upper: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Add a new row (a linear constraint) to the model.\n\n @param highs         A pointer to the Highs instance.\n @param lower         The lower bound of the row.\n @param upper         The upper bound of the row.\n @param num_new_nz    The number of non-zeros in the row\n @param index         An array of size [num_new_nz] with column indices.\n @param value         An array of size [num_new_nz] with column values.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_addRow(
        highs: *mut ::std::os::raw::c_void,
        lower: f64,
        upper: f64,
        num_new_nz: HighsInt,
        index: *const HighsInt,
        value: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Add multiple rows (linear constraints) to the model.\n\n @param highs         A pointer to the Highs instance.\n @param num_new_row   The number of new rows to add\n @param lower         An array of size [num_new_row] with the lower bounds of\n                      the rows.\n @param upper         An array of size [num_new_row] with the upper bounds of\n                      the rows.\n @param num_new_nz    The number of non-zeros in the rows.\n @param starts        The constraint coefficients are given as a matrix in\n                      compressed sparse row form by the arrays `starts`,\n                      `index`, and `value`. `starts` is an array of size\n                      [num_new_rows] with the start index of each row in\n                      indices and values.\n @param index         An array of size [num_new_nz] with column indices.\n @param value         An array of size [num_new_nz] with column values.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_addRows(
        highs: *mut ::std::os::raw::c_void,
        num_new_row: HighsInt,
        lower: *const f64,
        upper: *const f64,
        num_new_nz: HighsInt,
        starts: *const HighsInt,
        index: *const HighsInt,
        value: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the objective sense of the model.\n\n @param highs     A pointer to the Highs instance.\n @param sense     The new optimization sense in the form of a `kHighsObjSense`\n                  constant.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeObjectiveSense(
        highs: *mut ::std::os::raw::c_void,
        sense: HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the objective offset of the model.\n\n @param highs     A pointer to the Highs instance.\n @param offset    The new objective offset.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeObjectiveOffset(highs: *mut ::std::os::raw::c_void, offset: f64)
        -> HighsInt;
}
extern "C" {
    #[doc = " Change the integrality of a column.\n\n @param highs         A pointer to the Highs instance.\n @param col           The column index to change.\n @param integrality   The new integrality of the column in the form of a\n                      `kHighsVarType` constant.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeColIntegrality(
        highs: *mut ::std::os::raw::c_void,
        col: HighsInt,
        integrality: HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the integrality of multiple adjacent columns.\n\n @param highs         A pointer to the Highs instance.\n @param from_col      The index of the first column whose integrality changes.\n @param to_col        The index of the last column whose integrality\n                      changes.\n @param integrality   An array of length [to_col - from_col + 1] with the new\n                      integralities of the columns in the form of\n                      `kHighsVarType` constants.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeColsIntegralityByRange(
        highs: *mut ::std::os::raw::c_void,
        from_col: HighsInt,
        to_col: HighsInt,
        integrality: *const HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the integrality of multiple columns given by an array of indices.\n\n @param highs             A pointer to the Highs instance.\n @param num_set_entries   The number of columns to change.\n @param set               An array of size [num_set_entries] with the indices\n                          of the columns to change.\n @param integrality       An array of length [num_set_entries] with the new\n                          integralities of the columns in the form of\n                          `kHighsVarType` constants.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeColsIntegralityBySet(
        highs: *mut ::std::os::raw::c_void,
        num_set_entries: HighsInt,
        set: *const HighsInt,
        integrality: *const HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the integrality of multiple columns given by a mask.\n\n @param highs         A pointer to the Highs instance.\n @param mask          An array of length [num_col] with 1 if the column\n                      integrality should be changed and 0 otherwise.\n @param integrality   An array of length [num_col] with the new\n                      integralities of the columns in the form of\n                      `kHighsVarType` constants.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeColsIntegralityByMask(
        highs: *mut ::std::os::raw::c_void,
        mask: *const HighsInt,
        integrality: *const HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the objective coefficient of a column.\n\n @param highs     A pointer to the Highs instance.\n @param col       The index of the column fo change.\n @param cost      The new objective coefficient.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeColCost(
        highs: *mut ::std::os::raw::c_void,
        col: HighsInt,
        cost: f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the cost coefficients of multiple adjacent columns.\n\n @param highs     A pointer to the Highs instance.\n @param from_col  The index of the first column whose cost changes.\n @param to_col    The index of the last column whose cost changes.\n @param cost      An array of length [to_col - from_col + 1] with the new\n                  objective coefficients.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeColsCostByRange(
        highs: *mut ::std::os::raw::c_void,
        from_col: HighsInt,
        to_col: HighsInt,
        cost: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the cost of multiple columns given by an array of indices.\n\n @param highs             A pointer to the Highs instance.\n @param num_set_entries   The number of columns to change.\n @param set               An array of size [num_set_entries] with the indices\n                          of the columns to change.\n @param cost              An array of length [num_set_entries] with the new\n                          costs of the columns.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeColsCostBySet(
        highs: *mut ::std::os::raw::c_void,
        num_set_entries: HighsInt,
        set: *const HighsInt,
        cost: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the cost of multiple columns given by a mask.\n\n @param highs     A pointer to the Highs instance.\n @param mask      An array of length [num_col] with 1 if the column\n                  cost should be changed and 0 otherwise.\n @param cost      An array of length [num_col] with the new costs.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeColsCostByMask(
        highs: *mut ::std::os::raw::c_void,
        mask: *const HighsInt,
        cost: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the variable bounds of a column.\n\n @param highs     A pointer to the Highs instance.\n @param col       The index of the column whose bounds are to change.\n @param lower     The new lower bound.\n @param upper     The new upper bound.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeColBounds(
        highs: *mut ::std::os::raw::c_void,
        col: HighsInt,
        lower: f64,
        upper: f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the variable bounds of multiple adjacent columns.\n\n @param highs     A pointer to the Highs instance.\n @param from_col  The index of the first column whose bound changes.\n @param to_col    The index of the last column whose bound changes.\n @param lower     An array of length [to_col - from_col + 1] with the new\n                  lower bounds.\n @param upper     An array of length [to_col - from_col + 1] with the new\n                  upper bounds.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeColsBoundsByRange(
        highs: *mut ::std::os::raw::c_void,
        from_col: HighsInt,
        to_col: HighsInt,
        lower: *const f64,
        upper: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the bounds of multiple columns given by an array of indices.\n\n @param highs             A pointer to the Highs instance.\n @param num_set_entries   The number of columns to change.\n @param set               An array of size [num_set_entries] with the indices\n                          of the columns to change.\n @param lower             An array of length [num_set_entries] with the new\n                          lower bounds.\n @param upper             An array of length [num_set_entries] with the new\n                          upper bounds.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeColsBoundsBySet(
        highs: *mut ::std::os::raw::c_void,
        num_set_entries: HighsInt,
        set: *const HighsInt,
        lower: *const f64,
        upper: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the variable bounds of multiple columns given by a mask.\n\n @param highs     A pointer to the Highs instance.\n @param mask      An array of length [num_col] with 1 if the column\n                  bounds should be changed and 0 otherwise.\n @param lower     An array of length [num_col] with the new lower bounds.\n @param upper     An array of length [num_col] with the new upper bounds.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeColsBoundsByMask(
        highs: *mut ::std::os::raw::c_void,
        mask: *const HighsInt,
        lower: *const f64,
        upper: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the bounds of a row.\n\n @param highs     A pointer to the Highs instance.\n @param row       The index of the row whose bounds are to change.\n @param lower     The new lower bound.\n @param upper     The new upper bound.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeRowBounds(
        highs: *mut ::std::os::raw::c_void,
        row: HighsInt,
        lower: f64,
        upper: f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the bounds of multiple rows given by an array of indices.\n\n @param highs             A pointer to the Highs instance.\n @param num_set_entries   The number of rows to change.\n @param set               An array of size [num_set_entries] with the indices\n                          of the rows to change.\n @param lower             An array of length [num_set_entries] with the new\n                          lower bounds.\n @param upper             An array of length [num_set_entries] with the new\n                          upper bounds.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeRowsBoundsBySet(
        highs: *mut ::std::os::raw::c_void,
        num_set_entries: HighsInt,
        set: *const HighsInt,
        lower: *const f64,
        upper: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change the bounds of multiple rows given by a mask.\n\n @param highs     A pointer to the Highs instance.\n @param mask      An array of length [num_row] with 1 if the row\n                  bounds should be changed and 0 otherwise.\n @param lower     An array of length [num_row] with the new lower bounds.\n @param upper     An array of length [num_row] with the new upper bounds.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeRowsBoundsByMask(
        highs: *mut ::std::os::raw::c_void,
        mask: *const HighsInt,
        lower: *const f64,
        upper: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Change a coefficient in the constraint matrix.\n\n @param highs     A pointer to the Highs instance.\n @param row       The index of the row to change.\n @param col       The index of the column to change.\n @param value     The new constraint coefficient.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_changeCoeff(
        highs: *mut ::std::os::raw::c_void,
        row: HighsInt,
        col: HighsInt,
        value: f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get the objective sense.\n\n @param highs     A pointer to the Highs instance.\n @param sense     The location in which the current objective sense should be\n                  placed. The sense is a `kHighsObjSense` constant.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getObjectiveSense(
        highs: *const ::std::os::raw::c_void,
        sense: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get the objective offset.\n\n @param highs     A pointer to the Highs instance.\n @param offset    The location in which the current objective offset should be\n                  placed.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getObjectiveOffset(
        highs: *const ::std::os::raw::c_void,
        offset: *mut f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get data associated with multiple adjacent columns from the model.\n\n To query the constraint coefficients, this function should be called twice.\n\n First, call this function with `matrix_start`, `matrix_index`, and\n `matrix_value` as `NULL`. This call will populate `num_nz` with the number of\n nonzero elements in the corresponding section of the constraint matrix.\n\n Second, allocate new `matrix_index` and `matrix_value` arrays of length\n `num_nz` and call this function again to populate the new arrays with their\n contents.\n\n @param highs         A pointer to the Highs instance.\n @param from_col      The first column for which to query data for.\n @param to_col        The last column (inclusive) for which to query data for.\n @param num_col       An integer populated with the number of columns got from\n                      the model (this should equal `to_col - from_col + 1`).\n @param costs         An array of size [to_col - from_col + 1] for the column\n                      cost coefficients.\n @param lower         An array of size [to_col - from_col + 1] for the column\n                      lower bounds.\n @param upper         An array of size [to_col - from_col + 1] for the column\n                      upper bounds.\n @param num_nz        An integer to be populated with the number of non-zero\n                      elements in the constraint matrix.\n @param matrix_start  An array of size [to_col - from_col + 1] with the start\n                      indices of each column in `matrix_index` and\n                      `matrix_value`.\n @param matrix_index  An array of size [num_nz] with the row indices of each\n                      element in the constraint matrix.\n @param matrix_value  An array of size [num_nz] with the non-zero elements of\n                      the constraint matrix.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getColsByRange(
        highs: *const ::std::os::raw::c_void,
        from_col: HighsInt,
        to_col: HighsInt,
        num_col: *mut HighsInt,
        costs: *mut f64,
        lower: *mut f64,
        upper: *mut f64,
        num_nz: *mut HighsInt,
        matrix_start: *mut HighsInt,
        matrix_index: *mut HighsInt,
        matrix_value: *mut f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get data associated with multiple columns given by an array.\n\n This function is identical to `Highs_getColsByRange`, except for how the\n columns are specified.\n\n @param num_set_indices   The number of indices in `set`.\n @param set               An array of size [num_set_entries] with the column\n                          indices to get.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getColsBySet(
        highs: *const ::std::os::raw::c_void,
        num_set_entries: HighsInt,
        set: *const HighsInt,
        num_col: *mut HighsInt,
        costs: *mut f64,
        lower: *mut f64,
        upper: *mut f64,
        num_nz: *mut HighsInt,
        matrix_start: *mut HighsInt,
        matrix_index: *mut HighsInt,
        matrix_value: *mut f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get data associated with multiple columns given by a mask.\n\n This function is identical to `Highs_getColsByRange`, except for how the\n columns are specified.\n\n @param mask  An array of length [num_col] containing a `1` to get the column\n              and `0` otherwise.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getColsByMask(
        highs: *const ::std::os::raw::c_void,
        mask: *const HighsInt,
        num_col: *mut HighsInt,
        costs: *mut f64,
        lower: *mut f64,
        upper: *mut f64,
        num_nz: *mut HighsInt,
        matrix_start: *mut HighsInt,
        matrix_index: *mut HighsInt,
        matrix_value: *mut f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get data associated with multiple adjacent rows from the model.\n\n To query the constraint coefficients, this function should be called twice.\n\n First, call this function with `matrix_start`, `matrix_index`, and\n `matrix_value` as `NULL`. This call will populate `num_nz` with the number of\n nonzero elements in the corresponding section of the constraint matrix.\n\n Second, allocate new `matrix_index` and `matrix_value` arrays of length\n `num_nz` and call this function again to populate the new arrays with their\n contents.\n\n @param highs         A pointer to the Highs instance.\n @param from_row      The first row for which to query data for.\n @param to_row        The last row (inclusive) for which to query data for.\n @param num_row       An integer to be populated with the number of rows got\n                      from the smodel.\n @param lower         An array of size [to_row - from_row + 1] for the row\n                      lower bounds.\n @param upper         An array of size [to_row - from_row + 1] for the row\n                      upper bounds.\n @param num_nz        An integer to be populated with the number of non-zero\n                      elements in the constraint matrix.\n @param matrix_start  An array of size [to_row - from_row + 1] with the start\n                      indices of each row in `matrix_index` and\n                      `matrix_value`.\n @param matrix_index  An array of size [num_nz] with the column indices of\n                      each element in the constraint matrix.\n @param matrix_value  An array of size [num_nz] with the non-zero elements of\n                      the constraint matrix.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getRowsByRange(
        highs: *const ::std::os::raw::c_void,
        from_row: HighsInt,
        to_row: HighsInt,
        num_row: *mut HighsInt,
        lower: *mut f64,
        upper: *mut f64,
        num_nz: *mut HighsInt,
        matrix_start: *mut HighsInt,
        matrix_index: *mut HighsInt,
        matrix_value: *mut f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get data associated with multiple rows given by an array.\n\n This function is identical to `Highs_getRowsByRange`, except for how the\n rows are specified.\n\n @param num_set_indices   The number of indices in `set`.\n @param set               An array of size [num_set_entries] containing the\n                          row indices to get.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getRowsBySet(
        highs: *const ::std::os::raw::c_void,
        num_set_entries: HighsInt,
        set: *const HighsInt,
        num_row: *mut HighsInt,
        lower: *mut f64,
        upper: *mut f64,
        num_nz: *mut HighsInt,
        matrix_start: *mut HighsInt,
        matrix_index: *mut HighsInt,
        matrix_value: *mut f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get data associated with multiple rows given by a mask.\n\n This function is identical to `Highs_getRowsByRange`, except for how the\n rows are specified.\n\n @param mask  An array of length [num_row] containing a `1` to get the row and\n              `0` otherwise.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getRowsByMask(
        highs: *const ::std::os::raw::c_void,
        mask: *const HighsInt,
        num_row: *mut HighsInt,
        lower: *mut f64,
        upper: *mut f64,
        num_nz: *mut HighsInt,
        matrix_start: *mut HighsInt,
        matrix_index: *mut HighsInt,
        matrix_value: *mut f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get the name of a row.\n\n @param row   The index of the row to query.\n @param name  A pointer in which to store the name of the row. This must have\n              length `kHighsMaximumStringLength`.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getRowName(
        highs: *const ::std::os::raw::c_void,
        row: HighsInt,
        name: *mut ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get the index of a row from its name.\n\n If multiple rows have the same name, or if no row exists with `name`, this\n function returns `kHighsStatusError`.\n\n @param name A pointer of the name of the row to query.\n @param row  A pointer in which to store the index of the row\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getRowByName(
        highs: *const ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        row: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get the name of a column.\n\n @param col   The index of the column to query.\n @param name  A pointer in which to store the name of the column. This must\n              have length `kHighsMaximumStringLength`.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getColName(
        highs: *const ::std::os::raw::c_void,
        col: HighsInt,
        name: *mut ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get the index of a column from its name.\n\n If multiple columns have the same name, or if no column exists with `name`,\n this function returns `kHighsStatusError`.\n\n @param name A pointer of the name of the column to query.\n @param col  A pointer in which to store the index of the column\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getColByName(
        highs: *const ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        col: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Get the integrality of a column.\n\n @param col          The index of the column to query.\n @param integrality  An integer in which the integrality of the column should\n                     be placed. The integer is one of the `kHighsVarTypeXXX`\n                     constants.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getColIntegrality(
        highs: *const ::std::os::raw::c_void,
        col: HighsInt,
        integrality: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Delete multiple adjacent columns.\n\n @param highs     A pointer to the Highs instance.\n @param from_col  The index of the first column to delete.\n @param to_col    The index of the last column to delete.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_deleteColsByRange(
        highs: *mut ::std::os::raw::c_void,
        from_col: HighsInt,
        to_col: HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Delete multiple columns given by an array of indices.\n\n @param highs             A pointer to the Highs instance.\n @param num_set_entries   The number of columns to delete.\n @param set               An array of size [num_set_entries] with the indices\n                          of the columns to delete.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_deleteColsBySet(
        highs: *mut ::std::os::raw::c_void,
        num_set_entries: HighsInt,
        set: *const HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Delete multiple columns given by a mask.\n\n @param highs     A pointer to the Highs instance.\n @param mask      An array of length [num_col] with 1 if the column\n                  should be deleted and 0 otherwise.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_deleteColsByMask(
        highs: *mut ::std::os::raw::c_void,
        mask: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Delete multiple adjacent rows.\n\n @param highs     A pointer to the Highs instance.\n @param from_row  The index of the first row to delete.\n @param to_row    The index of the last row to delete.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_deleteRowsByRange(
        highs: *mut ::std::os::raw::c_void,
        from_row: ::std::os::raw::c_int,
        to_row: HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Delete multiple rows given by an array of indices.\n\n @param highs             A pointer to the Highs instance.\n @param num_set_entries   The number of rows to delete.\n @param set               An array of size [num_set_entries] with the indices\n                          of the rows to delete.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_deleteRowsBySet(
        highs: *mut ::std::os::raw::c_void,
        num_set_entries: HighsInt,
        set: *const HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Delete multiple rows given by a mask.\n\n @param highs     A pointer to the Highs instance.\n @param mask      An array of length [num_row] with `1` if the row should be\n                  deleted and `0` otherwise. The new index of any column not\n                  deleted is stored in place of the value `0`.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_deleteRowsByMask(
        highs: *mut ::std::os::raw::c_void,
        mask: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Scale a column by a constant.\n\n Scaling a column modifies the elements in the constraint matrix, the variable\n bounds, and the objective coefficient.\n\n @param highs     A pointer to the Highs instance.\n @param col       The index of the column to scale.\n @param scaleval  The value by which to scale the column. If `scaleval < 0`,\n                  the variable bounds flipped.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_scaleCol(
        highs: *mut ::std::os::raw::c_void,
        col: HighsInt,
        scaleval: f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Scale a row by a constant.\n\n @param highs     A pointer to the Highs instance.\n @param row       The index of the row to scale.\n @param scaleval  The value by which to scale the row. If `scaleval < 0`, the\n                  row bounds are flipped.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_scaleRow(
        highs: *mut ::std::os::raw::c_void,
        row: HighsInt,
        scaleval: f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Return the value of infinity used by HiGHS.\n\n @param highs     A pointer to the Highs instance.\n\n @returns The value of infinity used by HiGHS."]
    pub fn Highs_getInfinity(highs: *const ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[doc = " Return the number of columns in the model.\n\n @param highs     A pointer to the Highs instance.\n\n @returns The number of columns in the model."]
    pub fn Highs_getNumCol(highs: *const ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    #[doc = " Return the number of rows in the model.\n\n @param highs     A pointer to the Highs instance.\n\n @returns The number of rows in the model."]
    pub fn Highs_getNumRow(highs: *const ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    #[doc = " Return the number of nonzeros in the constraint matrix of the model.\n\n @param highs     A pointer to the Highs instance.\n\n @returns The number of nonzeros in the constraint matrix of the model."]
    pub fn Highs_getNumNz(highs: *const ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    #[doc = " Return the number of nonzeroes in the Hessian matrix of the model.\n\n @param highs     A pointer to the Highs instance.\n\n @returns The number of nonzeroes in the Hessian matrix of the model."]
    pub fn Highs_getHessianNumNz(highs: *const ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    #[doc = " Get the data from a HiGHS model.\n\n The input arguments have the same meaning (in a different order) to those\n used in `Highs_passModel`.\n\n Note that all arrays must be pre-allocated to the correct size before calling\n `Highs_getModel`. Use the following query methods to check the appropriate\n size:\n  - `Highs_getNumCol`\n  - `Highs_getNumRow`\n  - `Highs_getNumNz`\n  - `Highs_getHessianNumNz`\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getModel(
        highs: *const ::std::os::raw::c_void,
        a_format: HighsInt,
        q_format: HighsInt,
        num_col: *mut HighsInt,
        num_row: *mut HighsInt,
        num_nz: *mut HighsInt,
        hessian_num_nz: *mut HighsInt,
        sense: *mut HighsInt,
        offset: *mut f64,
        col_cost: *mut f64,
        col_lower: *mut f64,
        col_upper: *mut f64,
        row_lower: *mut f64,
        row_upper: *mut f64,
        a_start: *mut HighsInt,
        a_index: *mut HighsInt,
        a_value: *mut f64,
        q_start: *mut HighsInt,
        q_index: *mut HighsInt,
        q_value: *mut f64,
        integrality: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Set a primal (and possibly dual) solution as a starting point, then run\n crossover to compute a basic feasible solution.\n\n @param highs      A pointer to the Highs instance.\n @param num_col    The number of variables.\n @param num_row    The number of rows.\n @param col_value  An array of length [num_col] with optimal primal solution\n                   for each column.\n @param col_dual   An array of length [num_col] with optimal dual solution for\n                   each column. May be `NULL`, in which case no dual solution\n                   is passed.\n @param row_dual   An array of length [num_row] with optimal dual solution for\n                   each row. . May be `NULL`, in which case no dual solution\n                   is passed.\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_crossover(
        highs: *mut ::std::os::raw::c_void,
        num_col: ::std::os::raw::c_int,
        num_row: ::std::os::raw::c_int,
        col_value: *const f64,
        col_dual: *const f64,
        row_dual: *const f64,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Compute the ranging information for all costs and bounds. For\n nonbasic variables the ranging informaiton is relative to the\n active bound. For basic variables the ranging information relates\n to...\n\n For any values that are not required, pass NULL.\n\n @param highs                  A pointer to the Highs instance.\n @param col_cost_up_value      The upper range of the cost value\n @param col_cost_up_objective  The objective at the upper cost range\n @param col_cost_up_in_var     The variable entering the basis at the upper\n                               cost range\n @param col_cost_up_ou_var     The variable leaving the basis at the upper\n                               cost range\n @param col_cost_dn_value      The lower range of the cost value\n @param col_cost_dn_objective  The objective at the lower cost range\n @param col_cost_dn_in_var     The variable entering the basis at the lower\n                               cost range\n @param col_cost_dn_ou_var     The variable leaving the basis at the lower\n                               cost range\n @param col_bound_up_value     The upper range of the column bound value\n @param col_bound_up_objective The objective at the upper column bound range\n @param col_bound_up_in_var    The variable entering the basis at the upper\n                               column bound range\n @param col_bound_up_ou_var    The variable leaving the basis at the upper\n                               column bound range\n @param col_bound_dn_value     The lower range of the column bound value\n @param col_bound_dn_objective The objective at the lower column bound range\n @param col_bound_dn_in_var    The variable entering the basis at the lower\n                               column bound range\n @param col_bound_dn_ou_var    The variable leaving the basis at the lower\n                               column bound range\n @param row_bound_up_value     The upper range of the row bound value\n @param row_bound_up_objective The objective at the upper row bound range\n @param row_bound_up_in_var    The variable entering the basis at the upper\n                               row bound range\n @param row_bound_up_ou_var    The variable leaving the basis at the upper row\n                               bound range\n @param row_bound_dn_value     The lower range of the row bound value\n @param row_bound_dn_objective The objective at the lower row bound range\n @param row_bound_dn_in_var    The variable entering the basis at the lower\n                               row bound range\n @param row_bound_dn_ou_var    The variable leaving the basis at the lower row\n                               bound range\n\n @returns A `kHighsStatus` constant indicating whether the call succeeded."]
    pub fn Highs_getRanging(
        highs: *mut ::std::os::raw::c_void,
        col_cost_up_value: *mut f64,
        col_cost_up_objective: *mut f64,
        col_cost_up_in_var: *mut HighsInt,
        col_cost_up_ou_var: *mut HighsInt,
        col_cost_dn_value: *mut f64,
        col_cost_dn_objective: *mut f64,
        col_cost_dn_in_var: *mut HighsInt,
        col_cost_dn_ou_var: *mut HighsInt,
        col_bound_up_value: *mut f64,
        col_bound_up_objective: *mut f64,
        col_bound_up_in_var: *mut HighsInt,
        col_bound_up_ou_var: *mut HighsInt,
        col_bound_dn_value: *mut f64,
        col_bound_dn_objective: *mut f64,
        col_bound_dn_in_var: *mut HighsInt,
        col_bound_dn_ou_var: *mut HighsInt,
        row_bound_up_value: *mut f64,
        row_bound_up_objective: *mut f64,
        row_bound_up_in_var: *mut HighsInt,
        row_bound_up_ou_var: *mut HighsInt,
        row_bound_dn_value: *mut f64,
        row_bound_dn_objective: *mut f64,
        row_bound_dn_in_var: *mut HighsInt,
        row_bound_dn_ou_var: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    #[doc = " Releases all resources held by the global scheduler instance.\n\n It is not thread-safe to call this function while calling `Highs_run` or one\n of the `Highs_XXXcall` methods on any other Highs instance in any thread.\n\n After this function has terminated, it is guaranteed that eventually all\n previously created scheduler threads will terminate and allocated memory will\n be released.\n\n After this function has returned, the option value for the number of threads\n may be altered to a new value before the next call to `Highs_run` or one of\n the `Highs_XXXcall` methods.\n\n @param blocking   If the `blocking` parameter has a nonzero value, then this\n                   function will not return until all memory is freed, which\n                   might be desirable when debugging heap memory, but it\n                   requires the calling thread to wait for all scheduler\n                   threads to wake-up which is usually not necessary.\n\n @returns No status is returned since the function call cannot fail. Calling\n this function while any Highs instance is in use on any thread is\n undefined behavior and may cause crashes, but cannot be detected and hence\n is fully in the callers responsibility."]
    pub fn Highs_resetGlobalScheduler(blocking: HighsInt);
}
pub const HighsStatuskError: HighsInt = -1;
pub const HighsStatuskOk: HighsInt = 0;
pub const HighsStatuskWarning: HighsInt = 1;
extern "C" {
    pub fn Highs_call(
        num_col: HighsInt,
        num_row: HighsInt,
        num_nz: HighsInt,
        col_cost: *const f64,
        col_lower: *const f64,
        col_upper: *const f64,
        row_lower: *const f64,
        row_upper: *const f64,
        a_start: *const HighsInt,
        a_index: *const HighsInt,
        a_value: *const f64,
        col_value: *mut f64,
        col_dual: *mut f64,
        row_value: *mut f64,
        row_dual: *mut f64,
        col_basis_status: *mut HighsInt,
        row_basis_status: *mut HighsInt,
        model_status: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_runQuiet(highs: *mut ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    pub fn Highs_setHighsLogfile(
        highs: *mut ::std::os::raw::c_void,
        logfile: *const ::std::os::raw::c_void,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_setHighsOutput(
        highs: *mut ::std::os::raw::c_void,
        outputfile: *const ::std::os::raw::c_void,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_getIterationCount(highs: *const ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    pub fn Highs_getSimplexIterationCount(highs: *const ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    pub fn Highs_setHighsBoolOptionValue(
        highs: *mut ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: HighsInt,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_setHighsIntOptionValue(
        highs: *mut ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: HighsInt,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_setHighsDoubleOptionValue(
        highs: *mut ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: f64,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_setHighsStringOptionValue(
        highs: *mut ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_setHighsOptionValue(
        highs: *mut ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_getHighsBoolOptionValue(
        highs: *const ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_getHighsIntOptionValue(
        highs: *const ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_getHighsDoubleOptionValue(
        highs: *const ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: *mut f64,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_getHighsStringOptionValue(
        highs: *const ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_getHighsOptionType(
        highs: *const ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        type_: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_resetHighsOptions(highs: *mut ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    pub fn Highs_getHighsIntInfoValue(
        highs: *const ::std::os::raw::c_void,
        info: *const ::std::os::raw::c_char,
        value: *mut HighsInt,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_getHighsDoubleInfoValue(
        highs: *const ::std::os::raw::c_void,
        info: *const ::std::os::raw::c_char,
        value: *mut f64,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_getNumCols(highs: *const ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    pub fn Highs_getNumRows(highs: *const ::std::os::raw::c_void) -> HighsInt;
}
extern "C" {
    pub fn Highs_getHighsInfinity(highs: *const ::std::os::raw::c_void) -> f64;
}
extern "C" {
    pub fn Highs_getHighsRunTime(highs: *const ::std::os::raw::c_void) -> f64;
}
extern "C" {
    pub fn Highs_setOptionValue(
        highs: *mut ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> HighsInt;
}
extern "C" {
    pub fn Highs_getScaledModelStatus(highs: *const ::std::os::raw::c_void) -> HighsInt;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
